{"version":3,"sources":["../src/rules.js"],"names":["getIn","iterateFields","properties","SHOWN","DISABLED","REQUIRED","conditionTypes","EQUALITY","ALL","ANY","NOT","getConditionType","condition","customRuleConditions","undefined","Object","values","type","hasOwnProperty","keys","isShown","computedProperties","treePath","fieldProperties","shown","getComputedProperties","equal","fieldValue","params","includes","RulesParser","config","pathsToTreeMap","formValues","registeredRuleCondtions","computed","lastHiddenParent","fieldConfig","parentWasHidden","startsWith","computeShown","path","disabled","computeProperty","required","partialShownMap","shownRule","rules","find","rule","property","dependencies","Set","getConditionDependencies","when","forEach","dependencyPath","dependencyFields","reduce","acc","field","dependencyConfig","parseCondition","defaultValue","shownMap","found","args","arg","fieldPath","add","all","any","not","isFieldShown","context","conditionFn","conditions","currentCondition","parseRules","parser"],"mappings":"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","sourcesContent":["import { getIn } from 'formik';\nimport { iterateFields } from './utils';\n\nexport const properties = {\n\tSHOWN: 'shown',\n\tDISABLED: 'disabled',\n\tREQUIRED: 'required',\n};\n\nconst conditionTypes = {\n\tEQUALITY: 'eq',\n\tALL: 'all',\n\tANY: 'any',\n\tNOT: 'not',\n};\n\n/**\n * Gets the type (e.g. 'eq', 'all') from a condition object.\n *\n * If no type can be determined, returns undefined\n *\n * @param {Object} condition\n * @returns {String|undefined}\n */\nconst getConditionType = (condition, customRuleConditions = {}) => {\n\tif (!condition) {\n\t\treturn undefined;\n\t}\n\n\tfor (const type of Object.values(conditionTypes)) {\n\t\tif (condition.hasOwnProperty(type)) {\n\t\t\treturn type;\n\t\t}\n\t}\n\n\tfor (const type of Object.keys(customRuleConditions)) {\n\t\tif (condition.hasOwnProperty(type)) {\n\t\t\treturn type;\n\t\t}\n\t}\n\n\treturn undefined;\n};\n\nexport const isShown = (computedProperties, treePath) => {\n\tif (!computedProperties || !treePath) {\n\t\treturn true;\n\t}\n\n\tconst fieldProperties = computedProperties[treePath];\n\n\tif (fieldProperties && fieldProperties.shown) {\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\nexport const getComputedProperties = (computedProperties, treePath) => {\n\tif (!computedProperties || !treePath) {\n\t\treturn {};\n\t}\n\n\treturn computedProperties[treePath] || {};\n};\n\n/**\n * Implements the 'eq' condition.\n *\n * Returns true if any values in `args` match `value`, false otherwise.\n *\n * @param {*} value - The value to compare against\n * @param {Array<*>} args - The values to compare\n *\n * @returns {boolean}\n */\nconst equal = ({ fieldValue, params }) => {\n\treturn params.values.includes(fieldValue);\n};\n\nclass RulesParser {\n\tconstructor(config, pathsToTreeMap, formValues, registeredRuleCondtions) {\n\t\tthis.config = config;\n\t\tthis.pathsToTreeMap = pathsToTreeMap;\n\t\tthis.formValues = formValues;\n\t\tthis.registeredRuleCondtions = {\n\t\t\t[conditionTypes.EQUALITY]: equal,\n\t\t\t...registeredRuleCondtions,\n\t\t};\n\t}\n\n\tparseRules() {\n\t\tconst shown = {};\n\t\tconst computed = {};\n\t\tlet lastHiddenParent = null;\n\n\t\tfor (const { fieldConfig, treePath } of iterateFields(this.config)) {\n\t\t\tlet isShown;\n\t\t\tlet parentWasHidden;\n\n\t\t\tif (lastHiddenParent && treePath.startsWith(lastHiddenParent)) {\n\t\t\t\tisShown = false;\n\t\t\t\tparentWasHidden = true;\n\t\t\t} else {\n\t\t\t\tisShown = this.computeShown(fieldConfig, shown);\n\t\t\t}\n\n\t\t\tshown[fieldConfig.path] = isShown;\n\n\t\t\tif (!parentWasHidden && !isShown) {\n\t\t\t\tlastHiddenParent = treePath;\n\t\t\t}\n\n\t\t\tcomputed[treePath] = {\n\t\t\t\tshown: isShown,\n\t\t\t};\n\t\t}\n\n\t\t// After the shown property is resolved for all fields, other properties can be computed\n\t\tfor (const { fieldConfig, treePath } of iterateFields(this.config)) {\n\t\t\tcomputed[treePath] = {\n\t\t\t\t...(computed[treePath] || {}),\n\t\t\t\tdisabled: this.computeProperty(properties.DISABLED, !!fieldConfig.disabled, fieldConfig, shown),\n\t\t\t\trequired: this.computeProperty(properties.REQUIRED, !!fieldConfig.required, fieldConfig, shown),\n\t\t\t};\n\t\t}\n\n\t\treturn computed;\n\t}\n\n\tcomputeShown(fieldConfig, partialShownMap) {\n\t\tconst shownRule = (fieldConfig.rules || []).find(rule => rule.property === properties.SHOWN);\n\n\t\tif (!shownRule) {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst dependencies = new Set();\n\t\t// This will add any dependencies to the dependencies set, need to make this functional\n\t\tthis.getConditionDependencies(shownRule.when, dependencies);\n\n\t\tdependencies.forEach(dependencyPath => {\n\t\t\tconst dependencyFields = this.pathsToTreeMap[dependencyPath];\n\n\t\t\t// If we know there's a field with this path already shown, there's no need for extra calculations\n\t\t\tif (dependencyFields && !partialShownMap[dependencyPath]) {\n\t\t\t\tconst isShown = dependencyFields.reduce((acc, field) => {\n\t\t\t\t\tconst dependencyConfig = field.fieldConfig;\n\t\t\t\t\treturn acc || this.computeShown(dependencyConfig, partialShownMap);\n\t\t\t\t}, false);\n\n\t\t\t\tpartialShownMap[dependencyPath] = isShown;\n\t\t\t}\n\t\t});\n\n\t\treturn this.parseCondition(shownRule.when, partialShownMap);\n\t}\n\n\tcomputeProperty(property, defaultValue, fieldConfig, shownMap) {\n\t\tconst rule = (fieldConfig.rules || []).find(rule => rule.property === property);\n\n\t\tif (!rule) {\n\t\t\treturn defaultValue;\n\t\t}\n\n\t\treturn this.parseCondition(rule.when, shownMap);\n\t}\n\n\t/**\n\t* TODO make this functional\n\t*\n\t* Recursively find the dependencies of a condition.\n\t*\n\t* In this context, a field is a dependency of a condition if the field's path is referenced in the condition.\n\t*\n\t* @param {Object} condition - the condition\n\t* @param {Object} found - The partial list of dependencies found so far\n\t*/\n\tgetConditionDependencies(condition, found) {\n\t\tconst type = getConditionType(condition, this.registeredRuleCondtions);\n\n\t\tswitch (type) {\n\t\t\tcase conditionTypes.ALL:\n\t\t\tcase conditionTypes.ANY:\n\t\t\t\tconst args = condition[type];\n\t\t\t\t(args || []).forEach(arg => {\n\t\t\t\t\tthis.getConditionDependencies(arg, found);\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase conditionTypes.NOT:\n\t\t\t\tconst arg = condition[type];\n\t\t\t\tthis.getConditionDependencies(arg, found);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tconst params = condition[type];\n\n\t\t\t\tif (params && params.fieldPath) {\n\t\t\t\t\tfound.add(params.fieldPath);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * Takes a condition object, evaluates the condition against the current form values and returns a\n\t * boolean value.\n\t *\n\t * If a field is hidden, checking equality with that field should always return false. For this\n\t * reason, any field that is referenced in a condition must be evaluated first.\n\t *\n\t * @param {Object} condition - the condition to evaluate\n\t * @param {Object} formValues - The current values of the form\n\t * @param {Object} shownMap - The current visibility of fields in the form\n\t *\n\t * @returns {boolean}\n\t */\n\tparseCondition(condition, shownMap) {\n\t\tif (typeof condition === 'boolean') {\n\t\t\treturn condition;\n\t\t}\n\n\t\tconst type = getConditionType(condition, this.registeredRuleCondtions);\n\n\t\tswitch (type) {\n\t\t\tcase conditionTypes.ALL:\n\t\t\t\treturn this.all(shownMap)(...condition[conditionTypes.ALL]);\n\t\t\tcase conditionTypes.ANY:\n\t\t\t\treturn this.any(shownMap)(...condition[conditionTypes.ANY]);\n\t\t\tcase conditionTypes.NOT:\n\t\t\t\treturn this.not(shownMap)(condition[conditionTypes.NOT]);\n\t\t\tdefault: {\n\t\t\t\tconst params = condition[type];\n\n\t\t\t\tif (!type || !params) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tlet fieldValue;\n\t\t\t\tlet isFieldShown = true;\n\n\t\t\t\t// IF PATH CORRESPONDS TO A FIELD IN THIS FORM:\n\t\t\t\t// \t\tContinue normally\n\t\t\t\t// IF PATH IS NOT IN FORM:\n\t\t\t\t// \t\tGet that value from 'context', value is undefined if not found\n\t\t\t\tif (this.pathsToTreeMap[params.fieldPath]) {\n\t\t\t\t\tif (typeof params.fieldPath !== 'undefined') {\n\t\t\t\t\t\tfieldValue = getIn(this.formValues, params.fieldPath);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (shownMap && !shownMap[params.fieldPath]) {\n\t\t\t\t\t\tfieldValue = undefined;\n\t\t\t\t\t\tisFieldShown = false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfieldValue = getIn(this.config.context, params.fieldPath);\n\t\t\t\t}\n\n\t\t\t\tconst conditionFn = this.registeredRuleCondtions[type];\n\n\t\t\t\tif (conditionFn) {\n\t\t\t\t\treturn conditionFn({\n\t\t\t\t\t\tfieldValue,\n\t\t\t\t\t\tisFieldShown,\n\t\t\t\t\t\tparams,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Implements the 'all' condition.\n\t *\n\t * Returns a function that evaluates each condition and returns true if all provided conditions evalute to true.\n\t *\n\t * @param {Object} formValues - The current values of the form\n\t * @param {Object} shownMap - The current visibility of fields in the form\n\t *\n\t * @returns {function} - Takes n conditions and returns a boolean\n\t */\n\tall(shownMap) {\n\t\treturn (...conditions) => {\n\t\t\treturn conditions.reduce((acc, currentCondition) => {\n\t\t\t\treturn acc && this.parseCondition(currentCondition, shownMap); // eslint-disable-line no-use-before-define\n\t\t\t}, true);\n\t\t};\n\t}\n\n\t/**\n\t * Implements the 'any' condition.\n\t *\n\t * Returns a function that evaluates each condition and returns true if at least one of the provided conditions evalutes to true.\n\t *\n\t * @param {Object} formValues - The current values of the form\n\t * @param {Object} shownMap - The current visibility of fields in the form\n\t *\n\t * @returns {function} - Takes n conditions and returns a boolean\n\t */\n\tany(shownMap) {\n\t\treturn (...conditions) => {\n\t\t\treturn conditions.reduce((acc, currentCondition) => {\n\t\t\t\treturn acc || this.parseCondition(currentCondition, shownMap); // eslint-disable-line no-use-before-define\n\t\t\t}, false);\n\t\t};\n\t}\n\n\t/**\n\t * Implements the 'not' condition.\n\t *\n\t * Returns a function that evaluates to the negation of the provided condition.\n\t *\n\t * @param {Object} formValues - The current values of the form\n\t * @param {Object} shownMap - The current visibility of fields in the form\n\t *\n\t * @returns {function} - Takes a condition and returns a boolean\n\t */\n\tnot(shownMap) {\n\t\treturn condition => {\n\t\t\treturn !this.parseCondition(condition, shownMap); // eslint-disable-line no-use-before-define\n\t\t};\n\t}\n}\n\n\nexport const parseRules = (config, pathsToTreeMap, formValues, registeredRuleCondtions) => {\n\tconst parser = new RulesParser(config, pathsToTreeMap, formValues, registeredRuleCondtions);\n\treturn parser.parseRules();\n};\n"],"file":"rules.js"}